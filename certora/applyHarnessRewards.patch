diff -ruN common/rewards-distribution/dependencies/Hash.sol common/rewards-distribution/dependencies/Hash.sol
--- common/rewards-distribution/dependencies/Hash.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/dependencies/Hash.sol	2023-03-15 09:56:37.202247224 +0100
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+/// @notice Abstracted keccak function.
+library Hash {
+    function keccak(bytes32 a, bytes32 b) external pure returns (bytes32) {
+        return keccak256(abi.encode(a, b));
+    }
+}
diff -ruN common/rewards-distribution/dependencies/MerkleProof.sol common/rewards-distribution/dependencies/MerkleProof.sol
--- common/rewards-distribution/dependencies/MerkleProof.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/dependencies/MerkleProof.sol	2023-03-15 18:50:48.049799629 +0100
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./Hash.sol";
+
+/// @notice Harnessed MerkleProof library.
+library MerkleProof {
+    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
+        bytes32 computedHash = leaf;
+        for (uint256 i = 0; i < proof.length; i++) {
+            bytes32 proofElement = proof[i];
+            if (computedHash <= proofElement) {
+                // Hash(current computed hash + current element of the proof)
+                computedHash = Hash.keccak(computedHash, proofElement);
+            } else {
+                // Hash(current element of the proof + current computed hash)
+                computedHash = Hash.keccak(proofElement, computedHash);
+            }
+        }
+        return computedHash;
+    }
+
+    function processOne(bytes32 proof, bytes32 leaf) internal pure returns (bytes32 computedHash) {
+        computedHash = Hash.keccak(proof, leaf);
+    }
+
+    // function processOne(bytes32 proof, bytes32 leaf) internal pure returns (bytes32 computedHash) {
+    //     if (leaf <= proof) computedHash = Hash.keccak(leaf, proof);
+    //     else computedHash = Hash.keccak(proof, leaf);
+    // }
+}
diff -ruN common/rewards-distribution/dependencies/MorphoToken.sol common/rewards-distribution/dependencies/MorphoToken.sol
--- common/rewards-distribution/dependencies/MorphoToken.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/dependencies/MorphoToken.sol	2023-03-15 09:56:37.202247224 +0100
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "@rari-capital/solmate/src/tokens/ERC20.sol";
+
+contract MorphoToken is ERC20 {
+    constructor() ERC20("Morpho Token", "MORPHO", 18) {}
+}
diff -ruN common/rewards-distribution/dependencies/SafeTransferLib.sol common/rewards-distribution/dependencies/SafeTransferLib.sol
--- common/rewards-distribution/dependencies/SafeTransferLib.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/dependencies/SafeTransferLib.sol	2023-03-15 09:56:37.202247224 +0100
@@ -0,0 +1,17 @@
+// SPDX-License-Identifier: AGPL-3.0-only
+pragma solidity ^0.8.0;
+
+import {ERC20} from "@rari-capital/solmate/src/tokens/ERC20.sol";
+
+/// @notice Harnessed contract for transfer, originally written by Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)
+library SafeTransferLib {
+    function safeTransfer(
+        ERC20 token,
+        address to,
+        uint256 amount
+    ) internal {
+        bool success = token.transfer(to, amount);
+
+        require(success, "TRANSFER_FAILED");
+    }
+}
diff -ruN common/rewards-distribution/MerkleTree1.sol common/rewards-distribution/MerkleTree1.sol
--- common/rewards-distribution/MerkleTree1.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTree1.sol	2023-03-15 09:56:37.202247224 +0100
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./MerkleTreeMock.sol";
+
+contract MerkleTree1 is MerkleTreeMock {}
diff -ruN common/rewards-distribution/MerkleTree2.sol common/rewards-distribution/MerkleTree2.sol
--- common/rewards-distribution/MerkleTree2.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTree2.sol	2023-03-15 09:56:37.202247224 +0100
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./MerkleTreeMock.sol";
+
+contract MerkleTree2 is MerkleTreeMock {}
diff -ruN common/rewards-distribution/MerkleTreeLib.sol common/rewards-distribution/MerkleTreeLib.sol
--- common/rewards-distribution/MerkleTreeLib.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTreeLib.sol	2023-03-15 09:56:37.202247224 +0100
@@ -0,0 +1,110 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./dependencies/Hash.sol";
+
+library MerkleTreeLib {
+    struct Node {
+        bool created;
+        address left;
+        address right;
+        uint256 value;
+        bytes32 hashNode;
+    }
+
+    struct Tree {
+        mapping(address => Node) nodes;
+        address root;
+    }
+
+    function newAccount(
+        Tree storage tree,
+        address addr,
+        uint256 value
+    ) public {
+        Node storage node = tree.nodes[addr];
+        require(addr != address(0));
+        require(!node.created);
+        require(value != 0);
+
+        node.created = true;
+        node.value = value;
+        node.hashNode = Hash.keccak(bytes32(bytes20(addr)), bytes32(value));
+    }
+
+    function newNode(
+        Tree storage tree,
+        address parent,
+        address left,
+        address right
+    ) public {
+        Node storage parentNode = tree.nodes[parent];
+        Node storage leftNode = tree.nodes[left];
+        Node storage rightNode = tree.nodes[right];
+        require(parent != address(0));
+        require(!parentNode.created);
+        require(leftNode.created && rightNode.created);
+        require(leftNode.hashNode <= rightNode.hashNode);
+
+        parentNode.created = true;
+        parentNode.left = left;
+        parentNode.right = right;
+        parentNode.hashNode = Hash.keccak(leftNode.hashNode, rightNode.hashNode);
+    }
+
+    function setRoot(Tree storage tree, address addr) public {
+        require(tree.nodes[addr].created);
+        tree.root = addr;
+    }
+
+    function isWellFormed(Tree storage tree, address addr) public view returns (bool) {
+        Node storage node = tree.nodes[addr];
+
+        if (!node.created) return true;
+
+        if (node.left == address(0) && node.right == address(0))
+            return
+                node.value != 0 &&
+                node.hashNode == Hash.keccak(bytes32(bytes20(addr)), bytes32(node.value));
+        else {
+            // Well-formed nodes have exactly 0 or 2 children.
+            if (node.left == address(0) || node.right == address(0)) return false;
+            Node storage left = tree.nodes[node.left];
+            Node storage right = tree.nodes[node.right];
+            return
+                left.created &&
+                right.created &&
+                node.value == 0 &&
+                left.hashNode <= right.hashNode && // Well-formed tree.nodes should be pair sorted.
+                node.hashNode == Hash.keccak(left.hashNode, right.hashNode);
+        }
+    }
+
+    function findProof(Tree storage, address) public pure returns (bytes32[] memory) {
+        return new bytes32[](0); // TODO
+    }
+
+    function getRoot(Tree storage tree) public view returns (address) {
+        return tree.root;
+    }
+
+    function getCreated(Tree storage tree, address addr) public view returns (bool) {
+        return tree.nodes[addr].created;
+    }
+
+    function getLeft(Tree storage tree, address addr) public view returns (address) {
+        return tree.nodes[addr].left;
+    }
+
+    function getRight(Tree storage tree, address addr) public view returns (address) {
+        return tree.nodes[addr].right;
+    }
+
+    function getValue(Tree storage tree, address addr) public view returns (uint256) {
+        return tree.nodes[addr].value;
+    }
+
+    function getHash(Tree storage tree, address addr) public view returns (bytes32) {
+        return tree.nodes[addr].hashNode;
+    }
+}
diff -ruN common/rewards-distribution/MerkleTreeMock.sol common/rewards-distribution/MerkleTreeMock.sol
--- common/rewards-distribution/MerkleTreeMock.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTreeMock.sol	2023-03-15 09:56:37.202247224 +0100
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./MerkleTreeLib.sol";
+import "./RewardsDistributor.sol";
+
+contract MerkleTreeMock {
+    using MerkleTreeLib for MerkleTreeLib.Tree;
+
+    MerkleTreeLib.Tree tree;
+
+    bool public initialized;
+
+    constructor() {
+        require(initialized == false);
+        initialized = true;
+    }
+
+    function newAccount(address addr, uint256 value) public {
+        tree.newAccount(addr, value);
+    }
+
+    function newNode(
+        address parent,
+        address left,
+        address right
+    ) public {
+        tree.newNode(parent, left, right);
+    }
+
+    function setRoot(address addr) public {
+        tree.setRoot(addr);
+    }
+
+    function isWellFormed(address addr) public view returns (bool) {
+        return tree.isWellFormed(addr);
+    }
+
+    function getRoot() public view returns (address) {
+        return tree.getRoot();
+    }
+
+    function getCreated(address addr) public view returns (bool) {
+        return tree.getCreated(addr);
+    }
+
+    function getLeft(address addr) public view returns (address) {
+        return tree.getLeft(addr);
+    }
+
+    function getRight(address addr) public view returns (address) {
+        return tree.getRight(addr);
+    }
+
+    function getValue(address addr) public view returns (uint256) {
+        return tree.getValue(addr);
+    }
+
+    function getHash(address addr) public view returns (bytes32) {
+        return tree.getHash(addr);
+    }
+
+    function findAndClaimAt(address rewardsDistributor, address addr) public {
+        uint256 claimable = tree.getValue(addr);
+        bytes32[] memory proof = tree.findProof(addr);
+        RewardsDistributor(rewardsDistributor).claim(addr, claimable, proof);
+    }
+}
diff -ruN common/rewards-distribution/RewardsDistributor.sol common/rewards-distribution/RewardsDistributor.sol
--- common/rewards-distribution/RewardsDistributor.sol	2023-01-19 00:05:36.122272215 +0100
+++ common/rewards-distribution/RewardsDistributor.sol	2023-03-15 09:56:37.202247224 +0100
@@ -1,9 +1,10 @@
 // SPDX-License-Identifier: AGPL-3.0-only
 pragma solidity ^0.8.0;
 
-import "@rari-capital/solmate/src/utils/SafeTransferLib.sol";
+import "./dependencies/SafeTransferLib.sol"; // HARNESS
+import "./dependencies/MerkleProof.sol"; // HARNESS
+import "./dependencies/Hash.sol"; // HARNESS
 
-import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
 import "@openzeppelin/contracts/access/Ownable.sol";
 
 /// @title Morpho Rewards Distributor.
@@ -17,7 +18,6 @@
 
     ERC20 public immutable MORPHO;
     bytes32 public currRoot; // The merkle tree's root of the current rewards distribution.
-    bytes32 public prevRoot; // The merkle tree's root of the previous rewards distribution.
     mapping(address => uint256) public claimed; // The rewards already claimed. account -> amount.
 
     /// EVENTS ///
@@ -57,7 +57,6 @@
     /// @notice Updates the current merkle tree's root.
     /// @param _newRoot The new merkle tree's root.
     function updateRoot(bytes32 _newRoot) external onlyOwner {
-        prevRoot = currRoot;
         currRoot = _newRoot;
         emit RootUpdated(_newRoot);
     }
@@ -83,9 +82,9 @@
     ) external {
         bytes32 candidateRoot = MerkleProof.processProof(
             _proof,
-            keccak256(abi.encodePacked(_account, _claimable))
+            Hash.keccak(bytes32(bytes20(_account)), bytes32(_claimable))
         );
-        if (candidateRoot != currRoot && candidateRoot != prevRoot) revert ProofInvalidOrExpired();
+        if (candidateRoot != currRoot) revert ProofInvalidOrExpired();
 
         uint256 alreadyClaimed = claimed[_account];
         if (_claimable <= alreadyClaimed) revert AlreadyClaimed();
@@ -100,4 +99,24 @@
         MORPHO.safeTransfer(_account, amount);
         emit RewardsClaimed(_account, amount);
     }
+
+    function claimOne(
+        address _account,
+        uint256 _claimable,
+        bytes32 _proof
+    ) external view {
+        bytes32 candidateRoot = MerkleProof.processOne(
+            _proof,
+            Hash.keccak(bytes32(bytes20(_account)), bytes32(_claimable))
+        );
+        if (candidateRoot != currRoot) revert ProofInvalidOrExpired();
+    }
+
+    function address_to_bytes32(address _account) public pure returns (bytes32) {
+        return bytes32(bytes20(_account));
+    }
+
+    function uint256_to_bytes32(uint256 _claimable) public pure returns (bytes32) {
+        return bytes32(_claimable);
+    }
 }
diff -ruN .gitignore .gitignore
--- .gitignore	1970-01-01 01:00:00.000000000 +0100
+++ .gitignore	2023-03-15 09:56:37.202247224 +0100
@@ -0,0 +1 @@
+*
